# AI动态插件开发辅助文档

基于现有QQ动态插件的分析和AstrBot插件开发规范整理的开发指南。

## 1. 项目结构概览

### 核心文件结构
```
astrbot_plugin_ai_dynamic/
├── main.py           # 插件主文件
├── metadata.yaml     # 插件元数据
├── requirements.txt  # 依赖库
├── _conf_schema.json # 配置模式文件
├── core/            # 核心功能模块
│   ├── api.py      # API接口封装
│   ├── post.py     # 动态发布功能
│   └── utils.py    # 工具函数
└── data/           # 数据存储（图片、配置等）
```

## 2. QQ动态相关API接口分析

### 2.1 核心API模块 (core/api.py)
```python
class QZoneAPI:
    """QQ空间动态发布API封装类"""
    
    def __init__(self, cookies: str):
        """初始化API客户端
        
        Args:
            cookies: QQ空间登录凭据
        """
        
    async def publish_dynamic(self, content: str, images: List[str] = None) -> bool:
        """发布动态
        
        Args:
            content: 动态文本内容
            images: 图片文件路径列表
            
        Returns:
            发布是否成功
        """
        
    async def upload_image(self, image_path: str) -> str:
        """上传图片到QQ空间
        
        Args:
            image_path: 本地图片路径
            
        Returns:
            上传后的图片URL
        """
```

### 2.2 动态发布模块 (core/post.py)
```python
class DynamicPublisher:
    """动态发布器"""
    
    def __init__(self, api: QZoneAPI):
        self.api = api
        
    async def publish_text_dynamic(self, text: str) -> bool:
        """发布纯文本动态"""
        
    async def publish_image_dynamic(self, text: str, images: List[str]) -> bool:
        """发布图文动态"""
        
    async def publish_ai_generated_dynamic(self, prompt: str) -> bool:
        """发布AI生成的动态内容"""
```

### 2.3 工具函数模块 (core/utils.py)
```python
def validate_image_format(file_path: str) -> bool:
    """验证图片格式是否支持"""
    
def resize_image_if_needed(image_path: str, max_size: tuple = (1080, 1080)) -> str:
    """调整图片尺寸"""
    
def generate_dynamic_content(topic: str, style: str = "casual") -> str:
    """生成动态内容"""
```

## 3. AstrBot插件开发规范

### 3.1 插件基本结构
```python
from astrbot.api.event import filter, AstrMessageEvent, MessageEventResult
from astrbot.api.star import Context, Star, register
from astrbot.api import logger

@register("ai_dynamic", "作者名", "AI动态发布插件", "1.0.0", "仓库地址")
class AIDynamicPlugin(Star):
    def __init__(self, context: Context, config: dict = None):
        super().__init__(context)
        self.config = config or {}
        # 初始化QQ空间API
        self.qzone_api = None
        if self.config.get('qq_cookies'):
            self.qzone_api = QZoneAPI(self.config['qq_cookies'])
```

### 3.2 指令注册模式

#### 基础指令
```python
@filter.command("发动态")
async def publish_dynamic(self, event: AstrMessageEvent, content: str):
    """发布动态到QQ空间
    
    Args:
        content: 动态内容
    """
    if not self.qzone_api:
        yield event.plain_result("请先配置QQ空间登录信息")
        return
        
    try:
        success = await self.qzone_api.publish_dynamic(content)
        if success:
            yield event.plain_result("动态发布成功！")
        else:
            yield event.plain_result("动态发布失败")
    except Exception as e:
        logger.error(f"发布动态出错: {e}")
        yield event.plain_result("发布过程中出现错误")
```

#### 指令组模式
```python
@filter.command_group("动态")
def dynamic_group(self):
    """动态管理指令组"""
    pass

@dynamic_group.command("发布")
async def publish(self, event: AstrMessageEvent, content: str):
    """发布普通动态"""
    # /动态 发布 今天天气不错
    
@dynamic_group.command("ai生成")
async def ai_generate(self, event: AstrMessageEvent, topic: str, style: str = "随意"):
    """AI生成动态内容并发布"""
    # /动态 ai生成 今日心情 文艺
    
@dynamic_group.command("带图发布")
async def publish_with_images(self, event: AstrMessageEvent, content: str):
    """发布带图片的动态（需要在消息中包含图片）"""
    # 处理消息中的图片
    images = []
    for component in event.message_obj.message:
        if component.type == "image":
            images.append(component.file)
```

### 3.3 事件监听器
```python
@filter.event_message_type(filter.EventMessageType.ALL)
async def on_message(self, event: AstrMessageEvent):
    """监听所有消息，可用于自动化功能"""
    # 例如：检测到特定关键词自动发布动态
    message = event.message_str.lower()
    
    if "自动发布" in message and event.get_sender_id() in self.config.get('auto_users', []):
        # 触发自动发布逻辑
        pass
```

### 3.4 LLM集成
```python
@filter.command("ai动态")
async def ai_dynamic(self, event: AstrMessageEvent, topic: str):
    """使用AI生成并发布动态"""
    if not self.context.get_using_provider():
        yield event.plain_result("请先配置大语言模型")
        return
        
    # 构造AI提示
    system_prompt = "你是一个社交媒体内容创作者，擅长创作有趣的动态内容。"
    user_prompt = f"请为主题'{topic}'创作一条适合QQ空间的动态内容，要求轻松有趣，100字以内。"
    
    try:
        # 调用LLM
        llm_response = await self.context.get_using_provider().text_chat(
            prompt=user_prompt,
            system_prompt=system_prompt,
            contexts=[],
            session_id=None
        )
        
        if llm_response.role == "assistant":
            generated_content = llm_response.completion_text
            
            # 发布生成的内容
            if self.qzone_api:
                success = await self.qzone_api.publish_dynamic(generated_content)
                if success:
                    yield event.plain_result(f"AI生成动态发布成功！\n内容：{generated_content}")
                else:
                    yield event.plain_result(f"发布失败，但内容已生成：\n{generated_content}")
            else:
                yield event.plain_result(f"未配置QQ空间，生成内容：\n{generated_content}")
                
    except Exception as e:
        logger.error(f"AI生成动态失败: {e}")
        yield event.plain_result("AI生成失败，请稍后重试")
```

## 4. 配置管理

### 4.1 配置文件模式 (_conf_schema.json)
```json
{
  "qq_cookies": {
    "description": "QQ空间登录Cookies",
    "type": "text",
    "hint": "从浏览器开发者工具中获取的QQ空间登录凭据",
    "obvious_hint": true
  },
  "auto_publish": {
    "description": "是否启用自动发布",
    "type": "bool",
    "default": false,
    "hint": "开启后可根据设定规则自动发布动态"
  },
  "auto_users": {
    "description": "允许触发自动发布的用户ID列表",
    "type": "list",
    "default": [],
    "hint": "只有这些用户可以触发自动发布功能"
  },
  "content_filter": {
    "description": "内容过滤配置",
    "type": "object",
    "items": {
      "enable_filter": {
        "description": "启用内容过滤",
        "type": "bool",
        "default": true
      },
      "banned_words": {
        "description": "禁用词列表",
        "type": "list",
        "default": []
      }
    }
  },
  "ai_settings": {
    "description": "AI生成设置",
    "type": "object",
    "items": {
      "default_style": {
        "description": "默认生成风格",
        "type": "string",
        "default": "随意",
        "options": ["随意", "正式", "幽默", "文艺", "简洁"]
      },
      "max_length": {
        "description": "最大内容长度",
        "type": "int",
        "default": 100
      }
    }
  }
}
```

### 4.2 配置使用示例
```python
def __init__(self, context: Context, config: dict = None):
    super().__init__(context)
    self.config = config or {}
    
    # 获取配置项
    self.qq_cookies = self.config.get('qq_cookies', '')
    self.auto_publish = self.config.get('auto_publish', False)
    self.auto_users = self.config.get('auto_users', [])
    
    # 获取嵌套配置
    ai_settings = self.config.get('ai_settings', {})
    self.default_style = ai_settings.get('default_style', '随意')
    self.max_length = ai_settings.get('max_length', 100)
```

## 5. 错误处理和日志记录

### 5.1 异常处理模式
```python
@filter.command("发动态")
async def publish_dynamic(self, event: AstrMessageEvent, content: str):
    try:
        # 参数验证
        if not content.strip():
            yield event.plain_result("动态内容不能为空")
            return
            
        if not self.qzone_api:
            yield event.plain_result("请先在插件配置中设置QQ空间登录信息")
            return
            
        # 内容过滤
        if self._is_content_blocked(content):
            yield event.plain_result("内容包含敏感词汇，无法发布")
            return
            
        # 执行发布
        logger.info(f"用户 {event.get_sender_name()} 请求发布动态: {content[:50]}...")
        success = await self.qzone_api.publish_dynamic(content)
        
        if success:
            logger.info(f"动态发布成功")
            yield event.plain_result("✅ 动态发布成功！")
        else:
            logger.warning(f"动态发布失败")
            yield event.plain_result("❌ 动态发布失败，请检查网络或登录状态")
            
    except Exception as e:
        logger.error(f"发布动态时发生异常: {e}", exc_info=True)
        yield event.plain_result("发布过程中出现错误，请稍后重试")

def _is_content_blocked(self, content: str) -> bool:
    """检查内容是否被屏蔽"""
    filter_config = self.config.get('content_filter', {})
    if not filter_config.get('enable_filter', True):
        return False
        
    banned_words = filter_config.get('banned_words', [])
    return any(word in content for word in banned_words)
```

## 6. 消息链和富媒体处理

### 6.1 处理图片消息
```python
import astrbot.api.message_components as Comp

@filter.command("图片动态")
async def publish_image_dynamic(self, event: AstrMessageEvent, text: str = ""):
    """发布包含图片的动态"""
    
    # 提取消息中的图片
    images = []
    for component in event.message_obj.message:
        if isinstance(component, Comp.Image):
            if component.url:  # 网络图片
                images.append(component.url)
            elif component.file:  # 本地文件
                images.append(component.file)
    
    if not images:
        yield event.plain_result("请在消息中包含图片")
        return
        
    try:
        success = await self.qzone_api.publish_dynamic(text, images)
        if success:
            yield event.plain_result(f"✅ 图片动态发布成功！\n包含 {len(images)} 张图片")
        else:
            yield event.plain_result("❌ 图片动态发布失败")
    except Exception as e:
        logger.error(f"发布图片动态失败: {e}")
        yield event.plain_result("发布图片动态时出现错误")
```

### 6.2 构建富媒体回复
```python
@filter.command("动态预览")
async def preview_dynamic(self, event: AstrMessageEvent, content: str):
    """预览动态内容"""
    
    # 生成预览图片（可选）
    preview_image_path = await self._generate_preview_image(content)
    
    # 构建消息链
    chain = [
        Comp.Plain("📝 动态预览：\n"),
        Comp.Plain(content),
        Comp.Plain("\n\n"),
    ]
    
    if preview_image_path:
        chain.append(Comp.Image.fromFileSystem(preview_image_path))
        
    chain.extend([
        Comp.Plain("\n"),
        Comp.Plain("回复'确认发布'来发布此动态")
    ])
    
    yield event.chain_result(chain)
```

## 7. 异步任务和定时功能

### 7.1 定时发布功能
```python
import asyncio
from datetime import datetime, timedelta

def __init__(self, context: Context, config: dict = None):
    super().__init__(context)
    self.config = config or {}
    
    # 启动定时任务
    if self.config.get('enable_scheduled_post', False):
        asyncio.create_task(self._scheduled_post_task())

async def _scheduled_post_task(self):
    """定时发布任务"""
    while True:
        try:
            await asyncio.sleep(3600)  # 每小时检查一次
            
            # 检查是否有待发布的定时动态
            scheduled_posts = await self._get_scheduled_posts()
            
            for post in scheduled_posts:
                if self._should_publish_now(post):
                    await self._publish_scheduled_post(post)
                    
        except Exception as e:
            logger.error(f"定时发布任务异常: {e}")
```

## 8. 最佳实践和注意事项

### 8.1 性能优化
- 使用异步IO操作避免阻塞
- 合理设置API调用频率限制
- 图片处理使用适当的尺寸和格式

### 8.2 安全考虑
- 敏感信息（如cookies）加密存储
- 输入内容过滤和验证
- 限制用户权限和操作频率

### 8.3 用户体验
- 提供清晰的错误提示
- 支持操作确认和撤销
- 响应时间优化

### 8.4 扩展性设计
- 模块化的API接口设计
- 支持多平台动态发布的架构预留
- 插件配置的向后兼容性

## 9. 测试和调试

### 9.1 调试技巧
```python
# 使用logger进行调试
logger.debug(f"API调用参数: {params}")
logger.info(f"用户操作: {event.get_sender_name()} - {event.message_str}")

# 消息结构调试
print(f"原始消息: {event.message_obj.raw_message}")
print(f"消息链: {event.message_obj.message}")
```

### 9.2 测试用例设计
- 正常发布流程测试
- 异常情况处理测试
- 配置变更测试
- 多用户并发测试

这份文档涵盖了基于现有QQ动态插件和AstrBot开发规范的核心开发要点，可以作为AI动态插件开发的参考指南。